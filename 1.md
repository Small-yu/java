# 前缀和

#### 1.一维前缀和

就是用一个数组记录前面的和

即数组该位置之前的元素之和。

例如：[1,1,1,1]，则前缀和数组为[0,1,2,3,4]（**这里需要第一个元素为0**）

```c++
int a[4]={1,1,1,1};
int b[5];
b[0]=0;
for(int i=1;i<5;i++)
    b[i]=b[i-1]+a[i-1];
```



所以前缀和要比原数组的大小大一。

# 差分数组

前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。

**差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。**

#### 构造

`diff[i]` 就是 `nums[i]` 和 `nums[i-1]` 之差：

```c++
int[] diff = new int[nums.length];
// 构造差分数组
diff[0] = nums[0];
for (int i = 1; i < nums.length; i++) {
    diff[i] = nums[i] - nums[i - 1];
}
```

![img](D:\typora\image\2.jpeg)

通过这个 `diff` 差分数组是可以反推出原始数组 `nums` 的，代码逻辑如下：

```c++
int[] res = new int[diff.length];
// 根据差分数组构造结果数组
res[0] = diff[0];
for (int i = 1; i < diff.length; i++) {
    res[i] = res[i - 1] + diff[i];
}
```

**这样构造差分数组 `diff`，就可以快速进行区间增减的操作**，如果你想对区间 `nums[i..j]` 的元素全部加 3，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可：

![img](D:\typora\image\3.jpeg)

**原理很简单，回想 `diff` 数组反推 `nums` 数组的过程，`diff[i] += 3` 意味着给 `nums[i..]` 所有的元素都加了 3，然后 `diff[j+1] -= 3` 又意味着对于 `nums[j+1..]` 所有元素再减 3，那综合起来，是不是就是对 `nums[i..j]` 中的所有元素都加 3 了**？

# 基于范围的for循环

#### 概念

```c++
for(表达式 1; 表达式 2; 表达式 3)
{
    // 循环体
}

// 基于范围的for循环
for (declaration : expression)
{
    // 循环体
}   
```

#### 普通的for循环

它的工作流程是：

1. 执行表达式 1

2. 如果表达式 2 为 true,则执行循环体，否则跳出循环

3. 执行表达式3，会到第二步，重复执行。

**这种方式需要给出容器的两端，即开头和结尾。**

####  基于范围的for循环

它的工作流程：

1. 将 expression 中的元素拷贝到 declaration

2. 重复执行

**这种方式不需要给出容器的两端**，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算。

expression 可以是容器、数组、表达式、初始化列表等

1. 基于范围的 for 循环书写更为简单

2. 上述例子中，基于范围的for循环的容器 arr 只访问了一次，即 : 后边的表达式只执行一次；而普通for循环每次都要比较迭代器是否到了容器的边界

#### 种类

1. 值拷贝

```c++
// 只是将容器中的元素拷贝到 val,修改val不会影响容器中的值
for (auto val : arr)
	cout << val << endl;
```

2. 引用

```c++
// 使用引用,修改val会影响容器中的值，即可以直接修改容器的值，且避免了拷贝的开销
for (auto& val : arr)
	cout << val << endl;
```

3. 只读引用

```c++
// 使用const 修饰引用，使得只能只读，不能修改容器的数据
for (const auto& val : arr)
	cout << val << endl;
```

4. 关联式容器引用

遍历关联容器(set、map、multiset、multimap)时，**即使使用引用，也不能修改容器中的值**。对于关联容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在 for 循环中 auto & 会被视为 const auto &

```c++
// 使用const 修饰引用，使得只能只读，不能修改容器的数据
set<int> st{ 1,2,3,4,5,6 };
for (auto &val : st) 
    cout << val ++ << endl;		// 不能修改常量
```

# 滑动窗口

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

> PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了。如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

下面画图理解一下，`needs` 和 `window` 相当于计数器，分别记录 `T` 中字符出现次数和「窗口」中的相应字符的出现次数。

初始状态：

[![img](D:\typora\image\1.png)](https://labuladong.github.io/algo/images/slidingwindow/1.png)

增加 `right`，直到窗口 `[left, right)` 包含了 `T` 中所有字符：

[![img](D:\typora\image\2.png)](https://labuladong.github.io/algo/images/slidingwindow/2.png)

现在开始增加 `left`，缩小窗口 `[left, right)`：

[![img](D:\typora\image\3.png)](https://labuladong.github.io/algo/images/slidingwindow/3.png)

直到窗口中的字符串不再符合要求，`left` 不再继续移动：

[![img](D:\typora\image\4.png)](https://labuladong.github.io/algo/images/slidingwindow/4.png)

之后重复上述过程，先移动 `right`，再移动 `left`…… 直到 `right` 指针到达字符串 `S` 的末端，算法结束。

如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。**现在我们来看看这个滑动窗口代码框架怎么用**：

首先，初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```cpp
unordered_map<char, int> need, window;
for (char c : t) need[c]++;
```

然后，使用 `left` 和 `right` 变量初始化窗口的两端，不要忘了，区间 `[left, right)` 是左闭右开的，所以初始情况下窗口没有包含任何元素：

```cpp
int left = 0, right = 0;
int valid = 0; 
while (right < s.size()) {
    // 开始滑动
}
```

**其中 `valid` 变量表示窗口中满足 `need` 条件的字符个数**，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`。

**现在开始套模板，只需要思考以下几个问题**：

1、什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据？

2、什么时候窗口应该暂停扩大，开始移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据？

3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

如果一个字符进入窗口，应该增加 `window` 计数器；如果一个字符将移出窗口的时候，应该减少 `window` 计数器；当 `valid` 满足 `need` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

下面是完整代码：

```cpp
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0;
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c])
                valid++;
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }                    
        }
    }
    // 返回最小覆盖子串
    return len == INT_MAX ?
        "" : s.substr(start, len);
}
```